<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">//    abc_renderer.js: API to render to SVG/Raphael/whatever rendering engine
//    Copyright (C) 2010 Gregory Dyke (gregdyke at gmail dot com)
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.


/*global window, ABCJS, Math */

if (!window.ABCJS)
	window.ABCJS = {};

if (!window.ABCJS.write)
	window.ABCJS.write = {};

<span id='ABCJS-write-Renderer'>/**
</span> * Implements the API for rendering ABCJS Abstract Rendering Structure to a canvas/paper (e.g. SVG, Raphael, etc)
 * @param {Object} paper
 * @param {ABCJS.write.Glyphs} glyphs
 */
ABCJS.write.Renderer = function(paper, glyphs) {
  this.paper = paper;
  this.glyphs = glyphs;
  this.controller = null; //TODO-GD only used when drawing the ABCJS ARS to connect the controller with the elements for highlighting

  this.y = null; // renderer's y is managed by the controller
  this.minY = null // set at each drawing of a stave by the controller - place for lyrics, crescendo and other dynamcis
  this.scale = null; // renderer's scale is managed by the controller
  this.padding = null; // renderer's padding is managed by the controller
};


<span id='ABCJS-write-Renderer-method-beginGroup'>/**
</span> * Begin a group of glyphs that will always be moved, scaled and higlighted together
 */
ABCJS.write.Renderer.prototype.beginGroup = function () {
  this.path = [];
  this.lastM = [0,0];
  this.ingroup = true;
};

<span id='ABCJS-write-Renderer-method-addPath'>/**
</span> * Add a path to the current group
 * @param {Array} path
 * @private
 */
ABCJS.write.Renderer.prototype.addPath = function (path) {
  path = path || [];
  if (path.length===0) return;
  path[0][0]=&quot;m&quot;;
  path[0][1]-=this.lastM[0];
  path[0][2]-=this.lastM[1];
  this.lastM[0]+=path[0][1];
  this.lastM[1]+=path[0][2];
  this.path.push(path[0]);
  for (var i=1,ii=path.length;i&lt;ii;i++) {
    if (path[i][0]===&quot;m&quot;) {
      this.lastM[0]+=path[i][1];
      this.lastM[1]+=path[i][2];
    }
    this.path.push(path[i]);
  }
};

<span id='ABCJS-write-Renderer-method-endGroup'>/**
</span> * End a group of glyphs that will always be moved, scaled and higlighted together
 */
ABCJS.write.Renderer.prototype.endGroup = function () {
  this.ingroup = false;
  if (this.path.length===0) return null;
  var ret = this.paper.path().attr({path:this.path, stroke:&quot;none&quot;, fill:&quot;#000000&quot;});
  if (this.scale!==1) {
    ret.scale(this.scale, this.scale, 0, 0);
  }
  return ret;
};

<span id='ABCJS-write-Renderer-method-printStaveLine'>/**
</span> * gets scaled
 * @param {number} x1 start x
 * @param {number} x2 end x
 * @param {number} pitch pitch the stave line is drawn at
 */
ABCJS.write.Renderer.prototype.printStaveLine = function (x1,x2, pitch) {
  var isIE=/*@cc_on!@*/false;//IE detector
  var dy = 0.35;
  var fill = &quot;#000000&quot;;
  if (isIE) {
    dy = 1;
    fill = &quot;#666666&quot;;
  }
  var y = this.calcY(pitch);
  var pathString = ABCJS.write.sprintf(&quot;M %f %f L %f %f L %f %f L %f %f z&quot;, x1, y-dy, x2, y-dy,
			   x2, y+dy, x1, y+dy);
  var ret = this.paper.path().attr({path:pathString, stroke:&quot;none&quot;, fill:fill}).toBack();
  if (this.scale!==1) {
    ret.scale(this.scale, this.scale, 0, 0);
  }
  return ret;
};

<span id='ABCJS-write-Renderer-method-printStem'>/**
</span> * gets scaled if not in a group
 * @param {number} x1 x coordinate of the stem
 * @param {number} dx stem width
 * @param {number} y1 y coordinate of the stem bottom
 * @param {number} y2 y coordinate of the stem top
 */
ABCJS.write.Renderer.prototype.printStem = function (x, dx, y1, y2) {
  if (dx&lt;0) { // correct path &quot;handedness&quot; for intersection with other elements
    var tmp = y2;
    y2 = y1;
    y1 = tmp;
  }
  var isIE=/*@cc_on!@*/false;//IE detector
  var fill = &quot;#000000&quot;;
  if (isIE &amp;&amp; dx&lt;1) {
    dx = 1;
    fill = &quot;#666666&quot;;
  }
  if (~~x === x) x+=0.05; // raphael does weird rounding (for VML)
  var pathArray = [[&quot;M&quot;,x,y1],[&quot;L&quot;, x, y2],[&quot;L&quot;, x+dx, y2],[&quot;L&quot;,x+dx,y1],[&quot;z&quot;]];
  if (!isIE &amp;&amp; this.ingroup) {
    this.addPath(pathArray);
  } else {
    var ret = this.paper.path().attr({path:pathArray, stroke:&quot;none&quot;, fill:fill}).toBack();
    if (this.scale!==1) {
      ret.scale(this.scale, this.scale, 0, 0);
    }
    return ret;
  }
};

<span id='ABCJS-write-Renderer-method-printText'>/**
</span> * print text that gets scaled regardless
 * @param {number} x
 * @param {number} offset pitch at which the text should be placed
 * @param {String} text
 * @param {&quot;start&quot;|&quot;middle&quot;|&quot;end&quot;} anchor 
 */
ABCJS.write.Renderer.prototype.printText = function (x, offset, text, anchor) {
  anchor = anchor || &quot;start&quot;;
  var ret = this.paper.text(x*this.scale, this.calcY(offset)*this.scale, text).attr({&quot;text-anchor&quot;:anchor, &quot;font-size&quot;:12*this.scale});
//  if (this.scale!==1) {
//    ret.scale(this.scale, this.scale, 0, 0);
//  }
  return ret;
};

<span id='ABCJS-write-Renderer-method-printSymbol'>/** 
</span> * assumes this.y is set appropriately
 * if symbol is a multichar string without a . (as in scripts.staccato) 1 symbol per char is assumed
 * not scaled if not in printgroup
 */
ABCJS.write.Renderer.prototype.printSymbol = function(x, offset, symbol, scalex, scaley) {
	var el;
  if (!symbol) return null;
  if (symbol.length&gt;0 &amp;&amp; symbol.indexOf(&quot;.&quot;)&lt;0) {
    var elemset = this.paper.set();
    var dx =0;
    for (var i=0; i&lt;symbol.length; i++) {
      var ycorr = this.glyphs.getYCorr(symbol.charAt(i));
      el = this.glyphs.printSymbol(x+dx, this.calcY(offset+ycorr), symbol.charAt(i), this.paper);
      if (el) {
	elemset.push(el);
	dx+=this.glyphs.getSymbolWidth(symbol.charAt(i));
      } else {
	this.debugMsg(x,&quot;no symbol:&quot; +symbol);
      }
    }
    if (this.scale!==1) {
      elemset.scale(this.scale, this.scale, 0, 0);
    }
    return elemset;
  } else {
    var ycorr = this.glyphs.getYCorr(symbol);
    if (this.ingroup) {
      this.addPath(this.glyphs.getPathForSymbol(x, this.calcY(offset+ycorr), symbol, scalex, scaley));
    } else {
      el = this.glyphs.printSymbol(x, this.calcY(offset+ycorr), symbol, this.paper);
      if (el) {
	if (this.scale!==1) {
	  el.scale(this.scale, this.scale, 0, 0);
	}
	return el;
      } else
	this.debugMsg(x,&quot;no symbol:&quot; +symbol);
    }
    return null;    
  }
};


ABCJS.write.Renderer.prototype.printPath = function (attrs) {
  var ret = this.paper.path().attr(attrs);
  if (this.scale!==1) ret.scale(this.scale, this.scale, 0, 0);
  return ret;
};

ABCJS.write.Renderer.prototype.drawArc = function(x1, x2, pitch1, pitch2, above) {


  x1 = x1 + 6;
  x2 = x2 + 4;
  pitch1 = pitch1 + ((above)?1.5:-1.5);
  pitch2 = pitch2 + ((above)?1.5:-1.5);
  var y1 = this.calcY(pitch1);
  var y2 = this.calcY(pitch2);

  //unit direction vector
  var dx = x2-x1;
  var dy = y2-y1;
  var norm= Math.sqrt(dx*dx+dy*dy);
  var ux = dx/norm;
  var uy = dy/norm;

  var flatten = norm/3.5;
  var curve = ((above)?-1:1)*Math.min(25, Math.max(4, flatten));

  var controlx1 = x1+flatten*ux-curve*uy;
  var controly1 = y1+flatten*uy+curve*ux;
  var controlx2 = x2-flatten*ux-curve*uy;
  var controly2 = y2-flatten*uy+curve*ux;
  var thickness = 2;
  var pathString = ABCJS.write.sprintf(&quot;M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z&quot;, x1, y1,
			   controlx1, controly1, controlx2, controly2, x2, y2, 
			   controlx2-thickness*uy, controly2+thickness*ux, controlx1-thickness*uy, controly1+thickness*ux, x1, y1);
  var ret = this.paper.path().attr({path:pathString, stroke:&quot;none&quot;, fill:&quot;#000000&quot;});
  if (this.scale!==1) {
    ret.scale(this.scale, this.scale, 0, 0);
  }
  return ret;
};

ABCJS.write.Renderer.prototype.debugMsg = function(x, msg) {
  return this.paper.text(x, this.y, msg).scale(this.scale, this.scale, 0, 0);
};

ABCJS.write.Renderer.prototype.debugMsgLow = function(x, msg) {
    return this.paper.text(x, this.calcY(this.minY - 7), msg).attr({&quot;font-family&quot;:&quot;serif&quot;, &quot;font-size&quot;:12, &quot;text-anchor&quot;:&quot;begin&quot;}).scale(this.scale, this.scale, 0, 0);
};

/*
 * Gets scaled regardless
 */
ABCJS.write.Renderer.prototype.printLyrics = function(x, pitch, msg) {
    var el = this.paper.text(x, this.calcY(this.minY - 7), msg).attr({&quot;font-family&quot;:&quot;Times New Roman&quot;, &quot;font-weight&quot;:'bold', &quot;font-size&quot;:14, &quot;text-anchor&quot;:&quot;begin&quot;}).scale(this.scale, this.scale, 0, 0);
    el[0].setAttribute(&quot;class&quot;, &quot;abc-lyric&quot;);
    return el;
};

<span id='ABCJS-write-Renderer-method-calcY'>/**
</span> * Calculates the y for a given pitch value (relative to the stave the renderer is currently printing)
 * @param {number} ofs pitch value (bottom C on a G clef = 0, D=1, etc.)
 */
ABCJS.write.Renderer.prototype.calcY = function(ofs) {
  return this.y+((ABCJS.write.spacing.TOPNOTE-ofs)*ABCJS.write.spacing.STEP);
};

<span id='ABCJS-write-Renderer-method-printStave'>/**
</span> * Print @param {number} numLines. If there is 1 line it is the B line. Otherwise the bottom line is the E line.
 */
ABCJS.write.Renderer.prototype.printStave = function (startx, endx, numLines) {
	if (numLines === 1) {
		this.printStaveLine(startx,endx,6);
		return;
	}
	for (var i = 0; i &lt; numLines; i++) {
		this.printStaveLine(startx,endx,(i+1)*2);
	}
};








</pre>
</body>
</html>
