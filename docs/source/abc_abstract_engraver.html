<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// abc_abstract_engraver.js: Creates a data structure suitable for printing a line of abc
// Copyright (C) 2010 Gregory Dyke (gregdyke at gmail dot com)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.

/*global window, ABCJS */

if (!window.ABCJS)
        window.ABCJS = {};

if (!window.ABCJS.write)
        window.ABCJS.write = {};

ABCJS.write.getDuration = function(elem) {
  var d = 0;
  if (elem.duration) {
    d = elem.duration;
  }
  return d;
};

ABCJS.write.getDurlog = function(duration) {
        // TODO-PER: This is a hack to prevent a Chrome lockup. Duration should have been defined already,
        // but there's definitely a case where it isn't. [Probably something to do with triplets.]
        if (duration === undefined) {
                return 0;
        }
//        console.log(&quot;getDurlog: &quot; + duration);
  return Math.floor(Math.log(duration)/Math.log(2));
};

ABCJS.write.AbstractEngraver = function(glyphs, bagpipes) {
  this.glyphs = glyphs;
  this.isBagpipes = bagpipes;
  this.chartable = {rest:{0:&quot;rests.whole&quot;, 1:&quot;rests.half&quot;, 2:&quot;rests.quarter&quot;, 3:&quot;rests.8th&quot;, 4: &quot;rests.16th&quot;,5: &quot;rests.32nd&quot;, 6: &quot;rests.64th&quot;, 7: &quot;rests.128th&quot;},
                 note:{&quot;-1&quot;: &quot;noteheads.dbl&quot;, 0:&quot;noteheads.whole&quot;, 1:&quot;noteheads.half&quot;, 2:&quot;noteheads.quarter&quot;, 3:&quot;noteheads.quarter&quot;, 4:&quot;noteheads.quarter&quot;, 5:&quot;noteheads.quarter&quot;, 6:&quot;noteheads.quarter&quot;},
                 uflags:{3:&quot;flags.u8th&quot;, 4:&quot;flags.u16th&quot;, 5:&quot;flags.u32nd&quot;, 6:&quot;flags.u64th&quot;},
                 dflags:{3:&quot;flags.d8th&quot;, 4:&quot;flags.d16th&quot;, 5:&quot;flags.d32nd&quot;, 6:&quot;flags.d64th&quot;}};
  this.slurs = {};
  this.ties = [];
  this.slursbyvoice = {};
  this.tiesbyvoice = {};
  this.endingsbyvoice = {};
  this.s = 0; // current staff number
  this.v = 0; // current voice number on current staff
  this.stafflines = 5;
  this.tripletmultiplier = 1;
};

ABCJS.write.AbstractEngraver.prototype.getCurrentVoiceId = function() {
  return &quot;s&quot;+this.s+&quot;v&quot;+this.v;
};

ABCJS.write.AbstractEngraver.prototype.pushCrossLineElems = function() {
  this.slursbyvoice[this.getCurrentVoiceId()] = this.slurs;
  this.tiesbyvoice[this.getCurrentVoiceId()] = this.ties;
  this.endingsbyvoice[this.getCurrentVoiceId()] = this.partstartelem;
};

ABCJS.write.AbstractEngraver.prototype.popCrossLineElems = function() {
  this.slurs = this.slursbyvoice[this.getCurrentVoiceId()] || {};
  this.ties = this.tiesbyvoice[this.getCurrentVoiceId()] || [];
  this.partstartelem = this.endingsbyvoice[this.getCurrentVoiceId()];
};

ABCJS.write.AbstractEngraver.prototype.getElem = function() {
  if (this.abcline.length &lt;= this.pos)
    return null;
  return this.abcline[this.pos];
};

ABCJS.write.AbstractEngraver.prototype.getNextElem = function() {
        if (this.abcline.length &lt;= this.pos+1)
                return null;
    return this.abcline[this.pos+1];
};

ABCJS.write.AbstractEngraver.prototype.createABCLine = function(staffs) {
    this.minY = 2; // PER: This is the lowest that any note reaches. It will be used to set the dynamics row.
  this.staffgroup = new ABCJS.write.StaffGroupElement();
  for (this.s = 0; this.s &lt; staffs.length; this.s++) {
    this.createABCStaff(staffs[this.s]);
  }
  return this.staffgroup;
};

ABCJS.write.AbstractEngraver.prototype.createABCStaff = function(abcstaff) {

  var header = &quot;&quot;;
  if (abcstaff.bracket) header += &quot;bracket &quot;+abcstaff.bracket+&quot; &quot;;
  if (abcstaff.brace) header += &quot;brace &quot;+abcstaff.brace+&quot; &quot;;

  
  for (this.v = 0; this.v &lt; abcstaff.voices.length; this.v++) {
    this.voice = new ABCJS.write.VoiceElement(this.v,abcstaff.voices.length);
    if (this.v===0) {
      this.voice.barfrom = (abcstaff.connectBarLines===&quot;start&quot; || abcstaff.connectBarLines===&quot;continue&quot;);
      this.voice.barto = (abcstaff.connectBarLines===&quot;continue&quot; || abcstaff.connectBarLines===&quot;end&quot;);
    } else {
      this.voice.duplicate = true; // barlines and other duplicate info need not be createed
    }
    if (abcstaff.title &amp;&amp; abcstaff.title[this.v]) this.voice.header=abcstaff.title[this.v];
    // TODO make invisible if voice is duplicate
    this.voice.addChild(this.createClef(abcstaff.clef));
    this.voice.addChild(this.createKeySignature(abcstaff.key));
    if (abcstaff.meter) this.voice.addChild(this.createTimeSignature(abcstaff.meter));
    this.createABCVoice(abcstaff.voices[this.v]);
    this.staffgroup.addVoice(this.voice,this.s,this.stafflines);
  }
 
};

ABCJS.write.AbstractEngraver.prototype.createABCVoice = function(abcline) {
  this.popCrossLineElems();
  this.stemdir = (this.isBagpipes)?&quot;down&quot;:null;
  this.abcline = abcline;
  if (this.partstartelem) {
    this.partstartelem = new ABCJS.write.EndingElem(&quot;&quot;, null, null);
    this.voice.addOther(this.partstartelem);
  }
  for (var slur in this.slurs) {
    if (this.slurs.hasOwnProperty(slur)) {
      this.slurs[slur]= new ABCJS.write.TieElem(null, null, this.slurs[slur].above, this.slurs[slur].force);
        this.voice.addOther(this.slurs[slur]);
    }
  }
  for (var i=0; i&lt;this.ties.length; i++) {
    this.ties[i]=new ABCJS.write.TieElem(null, null, this.ties[i].above, this.ties[i].force);
    this.voice.addOther(this.ties[i]);
  }

  for (this.pos=0; this.pos&lt;this.abcline.length; this.pos++) {
    var abselems = this.createABCElement();
    for (i=0; i&lt;abselems.length; i++) {
      this.voice.addChild(abselems[i]);
    }
  }
  this.pushCrossLineElems();
};


// return an array of ABCJS.write.AbsoluteElement
ABCJS.write.AbstractEngraver.prototype.createABCElement = function() {
  var elemset = [];
  var elem = this.getElem();
  switch (elem.el_type) {
  case &quot;note&quot;:
    elemset = this.createBeam();
    break;
  case &quot;bar&quot;:
    elemset[0] = this.createBarLine(elem);
    if (this.voice.duplicate) elemset[0].invisible = true;
    break;
  case &quot;meter&quot;:
    elemset[0] = this.createTimeSignature(elem);
    if (this.voice.duplicate) elemset[0].invisible = true;
    break;
  case &quot;clef&quot;:
    elemset[0] = this.createClef(elem);
    if (this.voice.duplicate) elemset[0].invisible = true;
    break;
  case &quot;key&quot;:
    elemset[0] = this.createKeySignature(elem);
    if (this.voice.duplicate) elemset[0].invisible = true;
    break;
  case &quot;stem&quot;:
    this.stemdir=elem.direction;
    break;
  case &quot;part&quot;:
    var abselem = new ABCJS.write.AbsoluteElement(elem,0,0);
    abselem.addChild(new ABCJS.write.RelativeElement(elem.title, 0, 0, 18, {type:&quot;text&quot;, attributes:{&quot;font-weight&quot;:&quot;bold&quot;, &quot;font-size&quot;:&quot;&quot;+16*this.controller.scale+&quot;px&quot;, &quot;font-family&quot;:&quot;serif&quot;}}));
    elemset[0] = abselem;
    break;
//         case &quot;tempo&quot;:
//                this.printer.y = this.printer.printTempo(elem, this.printer.paper, this.printer.layouter, this.printer.y, this.printer, this.printer.x);
//                break;
  default:
    var abselem2 = new ABCJS.write.AbsoluteElement(elem,0,0);
    abselem2.addChild(new ABCJS.write.RelativeElement(&quot;element type &quot;+elem.el_type, 0, 0, 0, {type:&quot;debug&quot;}));
    elemset[0] = abselem2;
  }

  return elemset;
};

ABCJS.write.AbstractEngraver.prototype.createBeam = function() {
  var abselemset = [];
  
  if (this.getElem().startBeam &amp;&amp; !this.getElem().endBeam) {
    var beamelem = new ABCJS.write.BeamElem(this.stemdir);
         // PER: need two passes: the first one decides if the stems are up or down.
         // TODO-PER: This could be more efficient.
         var oldPos = this.pos;
         var abselem;
         while (this.getElem()) {
                 abselem = this.createNote(this.getElem(),true,true);
                 beamelem.add(abselem);
                 if (this.getElem().endBeam)
                        break;
                 this.pos++;
                }
         var dir = beamelem.calcDir();
         this.pos = oldPos;

         beamelem = new ABCJS.write.BeamElem(dir ? &quot;up&quot; : &quot;down&quot;);
         var oldDir = this.stemdir;
         this.stemdir = dir ? &quot;up&quot; : &quot;down&quot;;
    while (this.getElem()) {
      abselem = this.createNote(this.getElem(),true);
      abselemset.push(abselem);
                beamelem.add(abselem);
      if (this.getElem().endBeam) {
                break;
      }
      this.pos++;
    }
         this.stemdir = oldDir;
    this.voice.addOther(beamelem);
  } else {
    abselemset[0] = this.createNote(this.getElem());
  }
  return abselemset;
};

ABCJS.write.sortPitch = function(elem) {
  var sorted;
  do {
    sorted = true;
    for (var p = 0; p&lt;elem.pitches.length-1; p++) {
      if (elem.pitches[p].pitch&gt;elem.pitches[p+1].pitch) {
        sorted = false;
        var tmp = elem.pitches[p];
        elem.pitches[p] = elem.pitches[p+1];
        elem.pitches[p+1] = tmp;
      }
    }
  } while (!sorted);
};

ABCJS.write.AbstractEngraver.prototype.createNote = function(elem, nostem, dontDraw) { //stem presence: true for drawing stemless notehead
  var notehead = null;
  var grace= null;
  this.roomtaken = 0; // room needed to the left of the note
  this.roomtakenright = 0; // room needed to the right of the note
  var dotshiftx = 0; // room taken by chords with displaced noteheads which cause dots to shift
  var c=&quot;&quot;;
  var flag = null;
  var additionalLedgers = []; // PER: handle the case of [bc'], where the b doesn't have a ledger line

  var p, i, pp;
  var width, p1, p2, dx;

  var duration = ABCJS.write.getDuration(elem);
  if (duration === 0) { duration = 0.25; nostem = true; }        //PER: zero duration will draw a quarter note head.
  var durlog = Math.floor(Math.log(duration)/Math.log(2)); //TODO use getDurlog
  var dot=0;

  for (var tot = Math.pow(2,durlog), inc=tot/2; tot&lt;duration; dot++,tot+=inc,inc/=2);
  
  
  if (elem.startTriplet) {
         if (elem.startTriplet === 2)
         this.tripletmultiplier = 3/2;
         else
         this.tripletmultiplier=(elem.startTriplet-1)/elem.startTriplet;
  }
  

  var abselem = new ABCJS.write.AbsoluteElement(elem, duration * this.tripletmultiplier, 1);
  

  if (elem.rest) {
    var restpitch = 7;
    if (this.stemdir===&quot;down&quot;) restpitch = 3;
    if (this.stemdir===&quot;up&quot;) restpitch = 11;
    switch(elem.rest.type) {
    case &quot;rest&quot;:
      c = this.chartable.rest[-durlog];
      elem.averagepitch=restpitch;
      elem.minpitch=restpitch;
      elem.maxpitch=restpitch;
      break;
    case &quot;invisible&quot;:
    case &quot;spacer&quot;:
      c=&quot;&quot;;
    }
         if (!dontDraw)
    notehead = this.createNoteHead(abselem, c, {verticalPos:restpitch}, null, 0, -this.roomtaken, null, dot, 0, 1);
    if (notehead) abselem.addHead(notehead);
    this.roomtaken+=this.accidentalshiftx;
    this.roomtakenright = Math.max(this.roomtakenright,this.dotshiftx);

  } else {
         ABCJS.write.sortPitch(elem);
    
    // determine averagepitch, minpitch, maxpitch and stem direction
    var sum=0;
    for (p=0, pp=elem.pitches.length; p&lt;pp; p++) {
      sum += elem.pitches[p].verticalPos;
    }
    elem.averagepitch = sum/elem.pitches.length;
    elem.minpitch = elem.pitches[0].verticalPos;
      this.minY = Math.min(elem.minpitch, this.minY);
    elem.maxpitch = elem.pitches[elem.pitches.length-1].verticalPos;
    var dir = (elem.averagepitch&gt;=6) ? &quot;down&quot;: &quot;up&quot;;
    if (this.stemdir) dir=this.stemdir;
    
    // determine elements of chords which should be shifted
    for (p=(dir===&quot;down&quot;)?elem.pitches.length-2:1; (dir===&quot;down&quot;)?p&gt;=0:p&lt;elem.pitches.length; p=(dir===&quot;down&quot;)?p-1:p+1) {
      var prev = elem.pitches[(dir===&quot;down&quot;)?p+1:p-1];
      var curr = elem.pitches[p];
      var delta = (dir===&quot;down&quot;)?prev.pitch-curr.pitch:curr.pitch-prev.pitch;
      if (delta&lt;=1 &amp;&amp; !prev.printer_shift) {
        curr.printer_shift=(delta)?&quot;different&quot;:&quot;same&quot;;
        if (curr.verticalPos &gt; 11 || curr.verticalPos &lt; 1) {        // PER: add extra ledger line
          additionalLedgers.push(curr.verticalPos - (curr.verticalPos%2));
        }
        if (dir===&quot;down&quot;) {
         this.roomtaken = this.glyphs.getSymbolWidth(this.chartable.note[-durlog])+2;
        } else {
         dotshiftx = this.glyphs.getSymbolWidth(this.chartable.note[-durlog])+2;
        }
      }
    }
    
           // The accidentalSlot will hold a list of all the accidentals on this chord. Each element is a vertical place,
           // and contains a pitch, which is the last pitch that contains an accidental in that slot. The slots are numbered
         // from closest to the note to farther left. We only need to know the last accidental we placed because
         // we know that the pitches are sorted by now.
    this.accidentalSlot = [];

    for (p=0; p&lt;elem.pitches.length; p++) {

      if (!nostem) {
        if ((dir===&quot;down&quot; &amp;&amp; p!==0) || (dir===&quot;up&quot; &amp;&amp; p!==pp-1)) { // not the stemmed elem of the chord
         flag = null;
        } else {
         flag = this.chartable[(dir===&quot;down&quot;)?&quot;dflags&quot;:&quot;uflags&quot;][-durlog];
        }
        c = this.chartable.note[-durlog];
      } else {
        c=&quot;noteheads.quarter&quot;;
      }

                // The highest position for the sake of placing slurs is itself if the slur is internal. It is the highest position possible if the slur is for the whole chord.
                // If the note is the only one in the chord, then any slur it has counts as if it were on the whole chord.
                elem.pitches[p].highestVert = elem.pitches[p].verticalPos;
                var isTopWhenStemIsDown = (this.stemdir===&quot;up&quot; || dir===&quot;up&quot;) &amp;&amp; p===0;
                var isBottomWhenStemIsUp = (this.stemdir===&quot;down&quot; || dir===&quot;down&quot;) &amp;&amp; p===pp-1;
      if (!dontDraw &amp;&amp; (isTopWhenStemIsDown || isBottomWhenStemIsUp)) { // place to put slurs if not already on pitches

                 if (elem.startSlur || pp === 1) {
                 elem.pitches[p].highestVert = elem.pitches[pp-1].verticalPos;
                 if (this.stemdir===&quot;up&quot; || dir===&quot;up&quot;)
                                        elem.pitches[p].highestVert += 6;        // If the stem is up, then compensate for the length of the stem
                 }
                         if (elem.startSlur) {
          if (!elem.pitches[p].startSlur) elem.pitches[p].startSlur = []; //TODO possibly redundant, provided array is not optional
         for (i=0; i&lt;elem.startSlur.length; i++) {
         elem.pitches[p].startSlur.push(elem.startSlur[i]);
         }
        }

        if (!dontDraw &amp;&amp; elem.endSlur) {
                        elem.pitches[p].highestVert = elem.pitches[pp-1].verticalPos;
                        if (this.stemdir===&quot;up&quot; || dir===&quot;up&quot;)
                                elem.pitches[p].highestVert += 6;        // If the stem is up, then compensate for the length of the stem
          if (!elem.pitches[p].endSlur) elem.pitches[p].endSlur = []; //TODO possibly redundant, provided array is not optional
         for (i=0; i&lt;elem.endSlur.length; i++) {
         elem.pitches[p].endSlur.push(elem.endSlur[i]);
         }
        }
      }

                if (!dontDraw)
      notehead = this.createNoteHead(abselem, c, elem.pitches[p], dir, 0, -this.roomtaken, flag, dot, dotshiftx, 1);
      if (notehead) abselem.addHead(notehead);
      this.roomtaken += this.accidentalshiftx;
      this.roomtakenright = Math.max(this.roomtakenright,this.dotshiftx);
    }
      
    // draw stem from the furthest note to a pitch above/below the stemmed note
    if (!nostem &amp;&amp; durlog&lt;=-1) {
      p1 = (dir===&quot;down&quot;) ? elem.minpitch-7 : elem.minpitch+1/3;
                // PER added stemdir test to make the line meet the note.
      if (p1&gt;6 &amp;&amp; !this.stemdir) p1=6;
      p2 = (dir===&quot;down&quot;) ? elem.maxpitch-1/3 : elem.maxpitch+7;
                // PER added stemdir test to make the line meet the note.
      if (p2&lt;6 &amp;&amp; !this.stemdir) p2=6;
      dx = (dir===&quot;down&quot; || abselem.heads.length === 0)?0:abselem.heads[0].w;
      width = (dir===&quot;down&quot;)?1:-1;
      abselem.addExtra(new ABCJS.write.RelativeElement(null, dx, 0, p1, {&quot;type&quot;: &quot;stem&quot;, &quot;pitch2&quot;:p2, linewidth: width}));
        this.minY = Math.min(p1, this.minY);
        this.minY = Math.min(p2, this.minY);
    }
    
  }
  
  if (elem.lyric !== undefined) {
    var lyricStr = &quot;&quot;;
         window.ABCJS.parse.each(elem.lyric, function(ly) {
         lyricStr += ly.syllable + ly.divider + &quot;\n&quot;;
      });
    abselem.addRight(new ABCJS.write.RelativeElement(lyricStr, 0, lyricStr.length*5, 0, {type:&quot;debugLow&quot;}));
  }
  
  if (!dontDraw &amp;&amp; elem.gracenotes !== undefined) {
    var gracescale = 3/5;
    var gracebeam = null;
    if (elem.gracenotes.length&gt;1) {
      gracebeam = new ABCJS.write.BeamElem(&quot;grace&quot;,this.isBagpipes);
    }

    var graceoffsets = [];
    for (i=elem.gracenotes.length-1; i&gt;=0; i--) { // figure out where to place each gracenote
      this.roomtaken+=10;
      graceoffsets[i] = this.roomtaken;
      if (elem.gracenotes[i].accidental) {
        this.roomtaken+=7;
      }
    }

    for (i=0; i&lt;elem.gracenotes.length; i++) {
      var gracepitch = elem.gracenotes[i].verticalPos;

      flag = (gracebeam) ? null : this.chartable.uflags[(this.isBagpipes)?5:3];
      grace = this.createNoteHead(abselem, &quot;noteheads.quarter&quot;, elem.gracenotes[i], &quot;up&quot;, -graceoffsets[i], -graceoffsets[i], flag, 0, 0, gracescale);
      abselem.addExtra(grace);
                // PER: added acciaccatura slash
                if (elem.gracenotes[i].acciaccatura) {
                        var pos = elem.gracenotes[i].verticalPos+7*gracescale;        // the same formula that determines the flag position.
                        var dAcciaccatura = gracebeam ? 5 : 6;        // just an offset to make it line up correctly.
                        abselem.addRight(new ABCJS.write.RelativeElement(&quot;flags.ugrace&quot;, -graceoffsets[i]+dAcciaccatura, 0, pos, {scalex:gracescale, scaley: gracescale}));
                }
      if (gracebeam) { // give the beam the necessary info
        var pseudoabselem = {heads:[grace],
                         abcelem:{averagepitch: gracepitch, minpitch: gracepitch, maxpitch: gracepitch},
                         duration:(this.isBagpipes)?1/32:1/16};
        gracebeam.add(pseudoabselem);
      } else { // draw the stem
        p1 = gracepitch+1/3*gracescale;
        p2 = gracepitch+7*gracescale;
        dx = grace.dx + grace.w;
        width = -0.6;
        abselem.addExtra(new ABCJS.write.RelativeElement(null, dx, 0, p1, {&quot;type&quot;: &quot;stem&quot;, &quot;pitch2&quot;:p2, linewidth: width}));
      }
      
      if (i===0 &amp;&amp; !this.isBagpipes &amp;&amp; !(elem.rest &amp;&amp; (elem.rest.type===&quot;spacer&quot;||elem.rest.type===&quot;invisible&quot;))) this.voice.addOther(new ABCJS.write.TieElem(grace, notehead, false, true));
    }

    if (gracebeam) {
      this.voice.addOther(gracebeam);
    }
  }

  if (!dontDraw &amp;&amp; elem.decoration) {
    var addMark = this.createDecoration(elem.decoration, elem.maxpitch, (notehead)?notehead.w:0, abselem, this.roomtaken, dir, elem.minpitch);
         if (addMark) {
                 abselem.klass = &quot;mark&quot;;
         }
  }
  
  if (elem.barNumber) {
    abselem.addChild(new ABCJS.write.RelativeElement(elem.barNumber, -10, 0, 0, {type:&quot;debug&quot;}));
  }
  
  // ledger lines
  for (i=elem.maxpitch; i&gt;11; i--) {
    if (i%2===0 &amp;&amp; !elem.rest) {
      abselem.addChild(new ABCJS.write.RelativeElement(null, -2, this.glyphs.getSymbolWidth(c)+4, i, {type:&quot;ledger&quot;}));
    }
  }
  
  for (i=elem.minpitch; i&lt;1; i++) {
    if (i%2===0 &amp;&amp; !elem.rest) {
      abselem.addChild(new ABCJS.write.RelativeElement(null, -2, this.glyphs.getSymbolWidth(c)+4, i, {type:&quot;ledger&quot;}));
    }
  }

  for (i = 0; i &lt; additionalLedgers.length; i++) { // PER: draw additional ledgers
    var ofs = this.glyphs.getSymbolWidth(c);
    if (dir === 'down') ofs = -ofs;
    abselem.addChild(new ABCJS.write.RelativeElement(null, ofs-2, this.glyphs.getSymbolWidth(c)+4, additionalLedgers[i], {type:&quot;ledger&quot;}));
  }

  if (elem.chord !== undefined) { //16 -&gt; high E.
    for (i = 0; i &lt; elem.chord.length; i++) {
      var x = 0;
      var y = 16;
      switch (elem.chord[i].position) {
      case &quot;left&quot;:
        this.roomtaken+=7;
        x = -this.roomtaken;        // TODO-PER: This is just a guess from trial and error
        y = elem.averagepitch;
        abselem.addExtra(new ABCJS.write.RelativeElement(elem.chord[i].name, x, this.glyphs.getSymbolWidth(elem.chord[i].name[0])+4, y, {type:&quot;text&quot;}));
        break;
      case &quot;right&quot;:
        this.roomtakenright+=4;
        x = this.roomtakenright;// TODO-PER: This is just a guess from trial and error
        y = elem.averagepitch;
        abselem.addRight(new ABCJS.write.RelativeElement(elem.chord[i].name, x, this.glyphs.getSymbolWidth(elem.chord[i].name[0])+4, y, {type:&quot;text&quot;}));
        break;
      case &quot;below&quot;:
        y = elem.minpitch-4;
                         if (y &gt; -3) y = -3;
                         var eachLine = elem.chord[i].name.split(&quot;\n&quot;);
                         for (var ii = 0; ii &lt; eachLine.length; ii++) {
                                abselem.addChild(new ABCJS.write.RelativeElement(eachLine[ii], x, 0, y, {type:&quot;text&quot;}));
                                 y -= 3;        // TODO-PER: This should actually be based on the font height.
                         }
    break;
      default:
                         if (elem.chord[i].rel_position)
                                 abselem.addChild(new ABCJS.write.RelativeElement(elem.chord[i].name, x+elem.chord[i].rel_position.x, 0, elem.minpitch+elem.chord[i].rel_position.y/ABCJS.write.spacing.STEP, {type:&quot;text&quot;}));
                         else
                                 abselem.addChild(new ABCJS.write.RelativeElement(elem.chord[i].name, x, 0, y, {type:&quot;text&quot;}));
      }
    }
  }
    

  if (elem.startTriplet) {
    this.triplet = new ABCJS.write.TripletElem(elem.startTriplet, notehead, null, true); // above is opposite from case of slurs
         if (!dontDraw)
    this.voice.addOther(this.triplet);
  }

  if (elem.endTriplet &amp;&amp; this.triplet) {
    this.triplet.anchor2 = notehead;
    this.triplet = null;
    this.tripletmultiplier = 1;
  }

  return abselem;
};




ABCJS.write.AbstractEngraver.prototype.createNoteHead = function(abselem, c, pitchelem, dir, headx, extrax, flag, dot, dotshiftx, scale) {

  // TODO scale the dot as well
  var pitch = pitchelem.verticalPos;
  var notehead;
  var i;
  this.accidentalshiftx = 0;
  this.dotshiftx = 0;
  if (c === undefined)
    abselem.addChild(new ABCJS.write.RelativeElement(&quot;pitch is undefined&quot;, 0, 0, 0, {type:&quot;debug&quot;}));
  else if (c===&quot;&quot;) {
    notehead = new ABCJS.write.RelativeElement(null, 0, 0, pitch);
  } else {
    var shiftheadx = headx;
    if (pitchelem.printer_shift) {
      var adjust = (pitchelem.printer_shift===&quot;same&quot;)?1:0;
      shiftheadx = (dir===&quot;down&quot;)?-this.glyphs.getSymbolWidth(c)*scale+adjust:this.glyphs.getSymbolWidth(c)*scale-adjust;
    }
    notehead = new ABCJS.write.RelativeElement(c, shiftheadx, this.glyphs.getSymbolWidth(c)*scale, pitch, {scalex:scale, scaley: scale, extreme: ((dir===&quot;down&quot;)?&quot;below&quot;:&quot;above&quot;)});
    if (flag) {
      var pos = pitch+((dir===&quot;down&quot;)?-7:7)*scale;
      if (scale===1 &amp;&amp; (dir===&quot;down&quot;)?(pos&gt;6):(pos&lt;6)) pos=6;
      var xdelta = (dir===&quot;down&quot;)?headx:headx+notehead.w-0.6;
      abselem.addRight(new ABCJS.write.RelativeElement(flag, xdelta, this.glyphs.getSymbolWidth(flag)*scale, pos, {scalex:scale, scaley: scale}));
    }
    this.dotshiftx = notehead.w+dotshiftx-2+5*dot;
    for (;dot&gt;0;dot--) {
      var dotadjusty = (1-Math.abs(pitch)%2); //PER: take abs value of the pitch. And the shift still happens on ledger lines.
      abselem.addRight(new ABCJS.write.RelativeElement(&quot;dots.dot&quot;, notehead.w+dotshiftx-2+5*dot, this.glyphs.getSymbolWidth(&quot;dots.dot&quot;), pitch+dotadjusty));
    }
  }
        if (notehead)
                notehead.highestVert = pitchelem.highestVert;
  
  if (pitchelem.accidental) {
    var symb;
    switch (pitchelem.accidental) {
    case &quot;quartersharp&quot;:
      symb = &quot;accidentals.halfsharp&quot;;
        break;
    case &quot;dblsharp&quot;:
      symb = &quot;accidentals.dblsharp&quot;;
      break;
    case &quot;sharp&quot;:
      symb = &quot;accidentals.sharp&quot;;
      break;
    case &quot;quarterflat&quot;:
      symb = &quot;accidentals.halfflat&quot;;
      break;
    case &quot;flat&quot;:
      symb = &quot;accidentals.flat&quot;;
      break;
    case &quot;dblflat&quot;:
      symb = &quot;accidentals.dblflat&quot;;
      break;
    case &quot;natural&quot;:
      symb = &quot;accidentals.nat&quot;;
    }
         // if a note is at least a sixth away, it can share a slot with another accidental
         var accSlotFound = false;
         var accPlace = extrax;
         for (var j = 0; j &lt; this.accidentalSlot.length; j++) {
                 if (pitch - this.accidentalSlot[j][0] &gt;= 6) {
                         this.accidentalSlot[j][0] = pitch;
                         accPlace = this.accidentalSlot[j][1];
                         accSlotFound = true;
                         break;
                 }
         }
         if (accSlotFound === false) {
                 accPlace -= (this.glyphs.getSymbolWidth(symb)*scale+2);
                 this.accidentalSlot.push([pitch,accPlace]);
                 this.accidentalshiftx = (this.glyphs.getSymbolWidth(symb)*scale+2);
         }
    abselem.addExtra(new ABCJS.write.RelativeElement(symb, accPlace, this.glyphs.getSymbolWidth(symb), pitch, {scalex:scale, scaley: scale}));
  }
  
  if (pitchelem.endTie) {
    if (this.ties[0]) {
      this.ties[0].anchor2=notehead;
      this.ties = this.ties.slice(1,this.ties.length);
    }
  }
  
  if (pitchelem.startTie) {
    //PER: bug fix: var tie = new ABCJS.write.TieElem(notehead, null, (this.stemdir==&quot;up&quot; || dir==&quot;down&quot;) &amp;&amp; this.stemdir!=&quot;down&quot;,(this.stemdir==&quot;down&quot; || this.stemdir==&quot;up&quot;));
    var tie = new ABCJS.write.TieElem(notehead, null, (this.stemdir===&quot;down&quot; || dir===&quot;down&quot;) &amp;&amp; this.stemdir!==&quot;up&quot;,(this.stemdir===&quot;down&quot; || this.stemdir===&quot;up&quot;));
    this.ties[this.ties.length]=tie;
    this.voice.addOther(tie);
  }

  if (pitchelem.endSlur) {
    for (i=0; i&lt;pitchelem.endSlur.length; i++) {
      var slurid = pitchelem.endSlur[i];
      var slur;
      if (this.slurs[slurid]) {
        slur = this.slurs[slurid].anchor2=notehead;
        delete this.slurs[slurid];
      } else {
        slur = new ABCJS.write.TieElem(null, notehead, dir===&quot;down&quot;,(this.stemdir===&quot;up&quot; || dir===&quot;down&quot;) &amp;&amp; this.stemdir!==&quot;down&quot;, this.stemdir);
        this.voice.addOther(slur);
      }
      if (this.startlimitelem) {
        slur.startlimitelem = this.startlimitelem;
      }
    }
  }
  
  if (pitchelem.startSlur) {
    for (i=0; i&lt;pitchelem.startSlur.length; i++) {
      var slurid = pitchelem.startSlur[i].label;
      //PER: bug fix: var slur = new ABCJS.write.TieElem(notehead, null, (this.stemdir==&quot;up&quot; || dir==&quot;down&quot;) &amp;&amp; this.stemdir!=&quot;down&quot;, this.stemdir);
      var slur = new ABCJS.write.TieElem(notehead, null, (this.stemdir===&quot;down&quot; || dir===&quot;down&quot;) &amp;&amp; this.stemdir!==&quot;up&quot;, false);
      this.slurs[slurid]=slur;
      this.voice.addOther(slur);
    }
  }
  
  return notehead;

};

ABCJS.write.AbstractEngraver.prototype.createDecoration = function(decoration, pitch, width, abselem, roomtaken, dir, minPitch) {
  var dec;
  var compoundDec;        // PER: for decorations with two symbols
  var diminuendo;
    var crescendo;
  var unknowndecs = [];
  var yslot = (pitch&gt;9) ? pitch+3 : 12;
  var ypos;
        //var dir = (this.stemdir===&quot;down&quot; || pitch&gt;=6) &amp;&amp; this.stemdir!==&quot;up&quot;;
        var below = false;        // PER: whether decoration goes above or below.
        var yslotB = this.minY - 4; // (pitch&lt;1) ? pitch-9 : -6;
  var i;
  roomtaken = roomtaken || 0;
  if (pitch===5) yslot=14; // avoid upstem of the A
        var addMark = false; // PER: to allow the user to add a class whereever

  for (i=0;i&lt;decoration.length; i++) { // treat staccato and tenuto first (may need to shift other markers) //TODO, same with tenuto?
    if (decoration[i]===&quot;staccato&quot; || decoration[i]===&quot;tenuto&quot;) {
                var symbol = &quot;scripts.&quot; + decoration[i];
      ypos = (dir===&quot;down&quot;) ? pitch+2:minPitch-2;
                // don't place on a stave line. The stave lines are 2,4,6,8,10
                switch (ypos) {
                        case 2:
                        case 4:
                        case 6:
                        case 8:
                        case 10:
                                        if (dir === &quot;up&quot;) ypos--;
                                        else ypos++;
                                break;
                }
      if (pitch&gt;9) yslot++; // take up some room of those that are above
      var deltax = width/2;
      if (this.glyphs.getSymbolAlign(symbol)!==&quot;center&quot;) {
        deltax -= (this.glyphs.getSymbolWidth(dec)/2);
      }
      abselem.addChild(new ABCJS.write.RelativeElement(symbol, deltax, this.glyphs.getSymbolWidth(symbol), ypos));
    }
    if (decoration[i]===&quot;slide&quot; &amp;&amp; abselem.heads[0]) {
      ypos = abselem.heads[0].pitch;
      var blank1 = new ABCJS.write.RelativeElement(&quot;&quot;, -roomtaken-15, 0, ypos-1);
      var blank2 = new ABCJS.write.RelativeElement(&quot;&quot;, -roomtaken-5, 0, ypos+1);
      abselem.addChild(blank1);
      abselem.addChild(blank2);
      this.voice.addOther(new ABCJS.write.TieElem(blank1, blank2, false));
    }
  }

  for (i=0;i&lt;decoration.length; i++) {
         below = false;
    switch(decoration[i]) {
    case &quot;trill&quot;:dec=&quot;scripts.trill&quot;;break;
    case &quot;roll&quot;: dec=&quot;scripts.roll&quot;; break; //TODO put abc2ps roll in here
    case &quot;irishroll&quot;: dec=&quot;scripts.roll&quot;; break;
    case &quot;marcato&quot;: dec=&quot;scripts.umarcato&quot;; break;
    case &quot;marcato2&quot;: dec=&quot;scriopts.dmarcato&quot;; break;//other marcato
    case &quot;turn&quot;: dec=&quot;scripts.turn&quot;; break;
    case &quot;uppermordent&quot;: dec=&quot;scripts.prall&quot;; break;
    case &quot;mordent&quot;:
    case &quot;lowermordent&quot;: dec=&quot;scripts.mordent&quot;; break;
    case &quot;staccato&quot;:
    case &quot;tenuto&quot;:
    case &quot;slide&quot;: continue;
    case &quot;downbow&quot;: dec=&quot;scripts.downbow&quot;;break;
    case &quot;upbow&quot;: dec=&quot;scripts.upbow&quot;;break;
    case &quot;fermata&quot;: dec=&quot;scripts.ufermata&quot;; break;
    case &quot;invertedfermata&quot;: below = true; dec=&quot;scripts.dfermata&quot;; break;
    case &quot;breath&quot;: dec=&quot;,&quot;; break;
    case &quot;accent&quot;: dec=&quot;scripts.sforzato&quot;; break;
    case &quot;umarcato&quot;: dec=&quot;scripts.umarcato&quot;; break;
    case &quot;coda&quot;: dec=&quot;scripts.coda&quot;; break;
    case &quot;segno&quot;: dec=&quot;scripts.segno&quot;; break;
    case &quot;/&quot;: compoundDec=[&quot;flags.ugrace&quot;, 1]; continue;        // PER: added new decorations
    case &quot;//&quot;: compoundDec=[&quot;flags.ugrace&quot;, 2]; continue;
    case &quot;///&quot;: compoundDec=[&quot;flags.ugrace&quot;, 3]; continue;
    case &quot;////&quot;: compoundDec=[&quot;flags.ugrace&quot;, 4]; continue;
    case &quot;p&quot;:
    case &quot;mp&quot;:
    case &quot;pp&quot;:
    case &quot;ppp&quot;:
    case &quot;pppp&quot;:
    case &quot;f&quot;:
    case &quot;ff&quot;:
    case &quot;fff&quot;:
    case &quot;ffff&quot;:
    case &quot;sfz&quot;:
    case &quot;mf&quot;:
        var ddelem = new ABCJS.write.DynamicDecoration(abselem, decoration[i]);
        this.voice.addOther(ddelem);
        continue;
                case &quot;mark&quot;: addMark = true; continue;
        case &quot;diminuendo(&quot;:
                        ABCJS.write.AbstractEngraver.prototype.startDiminuendoX = abselem;
            diminuendo = undefined;
            continue;
        case &quot;diminuendo)&quot;:
            diminuendo = { start: ABCJS.write.AbstractEngraver.prototype.startDiminuendoX, stop: abselem};
                        ABCJS.write.AbstractEngraver.prototype.startDiminuendoX = undefined;
            continue;
        case &quot;crescendo(&quot;:
                        ABCJS.write.AbstractEngraver.prototype.startCrescendoX = abselem;
            crescendo = undefined;
            continue;
        case &quot;crescendo)&quot;:
            crescendo = { start: ABCJS.write.AbstractEngraver.prototype.startCrescendoX, stop: abselem};
                        ABCJS.write.AbstractEngraver.prototype.startCrescendoX = undefined;
            continue;
    default:
    unknowndecs[unknowndecs.length]=decoration[i];
    continue;
    }
         if (below) {
                 ypos = yslotB;
                 yslotB -= 4;
         } else {
                 ypos=yslot;
                 yslot+=3;
         }
    var deltax = width/2;
    if (this.glyphs.getSymbolAlign(dec)!==&quot;center&quot;) {
      deltax -= (this.glyphs.getSymbolWidth(dec)/2);
    }
    abselem.addChild(new ABCJS.write.RelativeElement(dec, deltax, this.glyphs.getSymbolWidth(dec), ypos));
  }
  if (compoundDec) {        // PER: added new decorations
         ypos = (dir === 'down') ? pitch+1:pitch+9;
         deltax = width/2;
         deltax += (dir === 'down') ? -5 : 3;
         for (var xx = 0; xx &lt; compoundDec[1]; xx++) {
                 ypos -= 1;
                 abselem.addChild(new ABCJS.write.RelativeElement(compoundDec[0], deltax, this.glyphs.getSymbolWidth(compoundDec[0]), ypos));
         }
  }
    if (diminuendo) {
        var delem = new ABCJS.write.CrescendoElem(diminuendo.start, diminuendo.stop, &quot;&gt;&quot;);
        this.voice.addOther(delem);
    }
    if (crescendo) {
        var celem = new ABCJS.write.CrescendoElem(crescendo.start, crescendo.stop, &quot;&lt;&quot;);
        this.voice.addOther(celem);
    }
  if (unknowndecs.length&gt;0)
      abselem.addChild(new ABCJS.write.RelativeElement(unknowndecs.join(','), 0, 0, 0, {type:&quot;debug&quot;}));
        return addMark;
};

ABCJS.write.AbstractEngraver.prototype.createBarLine = function (elem) {
// bar_thin, bar_thin_thick, bar_thin_thin, bar_thick_thin, bar_right_repeat, bar_left_repeat, bar_double_repeat

  var abselem = new ABCJS.write.AbsoluteElement(elem, 0, 10);
  var anchor = null; // place to attach part lines
  var dx = 0;



  var firstdots = (elem.type===&quot;bar_right_repeat&quot; || elem.type===&quot;bar_dbl_repeat&quot;);
  var firstthin = (elem.type!==&quot;bar_left_repeat&quot; &amp;&amp; elem.type!==&quot;bar_thick_thin&quot; &amp;&amp; elem.type!==&quot;bar_invisible&quot;);
  var thick = (elem.type===&quot;bar_right_repeat&quot; || elem.type===&quot;bar_dbl_repeat&quot; || elem.type===&quot;bar_left_repeat&quot; ||
         elem.type===&quot;bar_thin_thick&quot; || elem.type===&quot;bar_thick_thin&quot;);
  var secondthin = (elem.type===&quot;bar_left_repeat&quot; || elem.type===&quot;bar_thick_thin&quot; || elem.type===&quot;bar_thin_thin&quot; || elem.type===&quot;bar_dbl_repeat&quot;);
  var seconddots = (elem.type===&quot;bar_left_repeat&quot; || elem.type===&quot;bar_dbl_repeat&quot;);

  // limit positioning of slurs
  if (firstdots || seconddots) {
    for (var slur in this.slurs) {
      if (this.slurs.hasOwnProperty(slur)) {
        this.slurs[slur].endlimitelem = abselem;
      }
    }
    this.startlimitelem = abselem;
  }

  if (firstdots) {
    abselem.addRight(new ABCJS.write.RelativeElement(&quot;dots.dot&quot;, dx, 1, 7));
    abselem.addRight(new ABCJS.write.RelativeElement(&quot;dots.dot&quot;, dx, 1, 5));
    dx+=6; //2 hardcoded, twice;
  }

  if (firstthin) {
    anchor = new ABCJS.write.RelativeElement(null, dx, 1, 2, {&quot;type&quot;: &quot;bar&quot;, &quot;pitch2&quot;:10, linewidth:0.6});
    abselem.addRight(anchor);
  }

  if (elem.type===&quot;bar_invisible&quot;) {
    anchor = new ABCJS.write.RelativeElement(null, dx, 1, 2, {&quot;type&quot;: &quot;none&quot;, &quot;pitch2&quot;:10, linewidth:0.6});
    abselem.addRight(anchor);
  }

  if (elem.decoration) {
    this.createDecoration(elem.decoration, 12, (thick)?3:1, abselem, 0, &quot;down&quot;, 2);
  }

  if (thick) {
    dx+=4; //3 hardcoded;
    anchor = new ABCJS.write.RelativeElement(null, dx, 4, 2, {&quot;type&quot;: &quot;bar&quot;, &quot;pitch2&quot;:10, linewidth:4});
    abselem.addRight(anchor);
    dx+=5;
  }
  
// if (this.partstartelem &amp;&amp; (thick || (firstthin &amp;&amp; secondthin))) { // means end of nth part
// this.partstartelem.anchor2=anchor;
// this.partstartelem = null;
// }

  if (this.partstartelem &amp;&amp; elem.endEnding) {
    this.partstartelem.anchor2=anchor;
    this.partstartelem = null;
  }

  if (secondthin) {
    dx+=3; //3 hardcoded;
    anchor = new ABCJS.write.RelativeElement(null, dx, 1, 2, {&quot;type&quot;: &quot;bar&quot;, &quot;pitch2&quot;:10, linewidth:0.6});
    abselem.addRight(anchor); // 3 is hardcoded
  }

  if (seconddots) {
    dx+=3; //3 hardcoded;
    abselem.addRight(new ABCJS.write.RelativeElement(&quot;dots.dot&quot;, dx, 1, 7));
    abselem.addRight(new ABCJS.write.RelativeElement(&quot;dots.dot&quot;, dx, 1, 5));
  } // 2 is hardcoded

  if (elem.startEnding) {
    this.partstartelem = new ABCJS.write.EndingElem(elem.startEnding, anchor, null);
    this.voice.addOther(this.partstartelem);
  }

  return abselem;        

};

ABCJS.write.AbstractEngraver.prototype.createClef = function(elem) {
  var clef = &quot;clefs.G&quot;;
  var octave = 0;
  var abselem = new ABCJS.write.AbsoluteElement(elem,0,10);
  switch (elem.type) {
  case &quot;treble&quot;: break;
  case &quot;tenor&quot;: clef=&quot;clefs.C&quot;; break;
  case &quot;alto&quot;: clef=&quot;clefs.C&quot;; break;
  case &quot;bass&quot;: clef=&quot;clefs.F&quot;; break;
  case 'treble+8': octave = 1; break;
  case 'tenor+8':clef=&quot;clefs.C&quot;; octave = 1; break;
  case 'bass+8': clef=&quot;clefs.F&quot;; octave = 1; break;
  case 'alto+8': clef=&quot;clefs.C&quot;; octave = 1; break;
  case 'treble-8': octave = -1; break;
  case 'tenor-8':clef=&quot;clefs.C&quot;; octave = -1; break;
  case 'bass-8': clef=&quot;clefs.F&quot;; octave = -1; break;
  case 'alto-8': clef=&quot;clefs.C&quot;; octave = -1; break;
  case 'none': clef=&quot;&quot;; break;
  case 'perc': clef=&quot;clefs.perc&quot;; break;
  default: abselem.addChild(new ABCJS.write.RelativeElement(&quot;clef=&quot;+elem.type, 0, 0, 0, {type:&quot;debug&quot;}));
  }
// if (elem.verticalPos) {
// pitch = elem.verticalPos;
// }
  var dx =10;
  if (clef!==&quot;&quot;) {
    abselem.addRight(new ABCJS.write.RelativeElement(clef, dx, this.glyphs.getSymbolWidth(clef), elem.clefPos));
  }
  if (octave!==0) {
    var scale= 2/3;
    var adjustspacing = (this.glyphs.getSymbolWidth(clef)-this.glyphs.getSymbolWidth(&quot;8&quot;)*scale)/2;
    abselem.addRight(new ABCJS.write.RelativeElement(&quot;8&quot;, dx+adjustspacing, this.glyphs.getSymbolWidth(&quot;8&quot;)*scale, (octave&gt;0)?16:-2, {scalex:scale, scaley:scale}));
  }

  if (elem.stafflines===0) {
    this.stafflines = 0;
  } else {
    this.stafflines =elem.stafflines;
  }

  return abselem;
};


ABCJS.write.AbstractEngraver.prototype.createKeySignature = function(elem) {
  var abselem = new ABCJS.write.AbsoluteElement(elem,0,10);
  var dx = 0;
  if (elem.accidentals) {
         window.ABCJS.parse.each(elem.accidentals, function(acc) {
                var symbol = (acc.acc === &quot;sharp&quot;) ? &quot;accidentals.sharp&quot; : (acc.acc === &quot;natural&quot;) ? &quot;accidentals.nat&quot; : &quot;accidentals.flat&quot;;
                //var notes = { 'A': 5, 'B': 6, 'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G':4, 'a': 12, 'b': 13, 'c': 7, 'd': 8, 'e': 9, 'f': 10, 'g':11 };
                abselem.addRight(new ABCJS.write.RelativeElement(symbol, dx, this.glyphs.getSymbolWidth(symbol), acc.verticalPos));
                dx += this.glyphs.getSymbolWidth(symbol)+2;
         }, this);
  }
  this.startlimitelem = abselem; // limit ties here
  return abselem;
};

ABCJS.write.AbstractEngraver.prototype.createTimeSignature= function(elem) {

  var abselem = new ABCJS.write.AbsoluteElement(elem,0,20);
  if (elem.type === &quot;specified&quot;) {
    //TODO make the alignment for time signatures centered
    for (var i = 0; i &lt; elem.value.length; i++) {
      if (i !== 0)
        abselem.addRight(new ABCJS.write.RelativeElement('+', i*20-9, this.glyphs.getSymbolWidth(&quot;+&quot;), 7));
      if (elem.value[i].den) {
        abselem.addRight(new ABCJS.write.RelativeElement(elem.value[i].num, i*20, this.glyphs.getSymbolWidth(elem.value[i].num.charAt(0))*elem.value[i].num.length, 9));
        abselem.addRight(new ABCJS.write.RelativeElement(elem.value[i].den, i*20, this.glyphs.getSymbolWidth(elem.value[i].den.charAt(0))*elem.value[i].den.length, 5));
      } else {
        abselem.addRight(new ABCJS.write.RelativeElement(elem.value[i].num, i*20, this.glyphs.getSymbolWidth(elem.value[i].num.charAt(0))*elem.value[i].num.length, 7));
      }
    }
  } else if (elem.type === &quot;common_time&quot;) {
    abselem.addRight(new ABCJS.write.RelativeElement(&quot;timesig.common&quot;, 0, this.glyphs.getSymbolWidth(&quot;timesig.common&quot;), 7));
    
  } else if (elem.type === &quot;cut_time&quot;) {
    abselem.addRight(new ABCJS.write.RelativeElement(&quot;timesig.cut&quot;, 0, this.glyphs.getSymbolWidth(&quot;timesig.cut&quot;), 7));
  }
  this.startlimitelem = abselem; // limit ties here
  return abselem;
};</pre>
</body>
</html>
