<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">//    abc_tokenizer.js: tokenizes an ABC Music Notation string to support abc_parse.
//    Copyright (C) 2010 Paul Rosen (paul at paulrosen dot net)
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

/*global window */

if (!window.ABCJS)
	window.ABCJS = {};

if (!window.ABCJS.parse)
	window.ABCJS.parse = {};

// this is a series of functions that get a particular element out of the passed stream.
// the return is the number of characters consumed, so 0 means that the element wasn't found.
// also returned is the element found. This may be a different length because spaces may be consumed that aren't part of the string.
// The return structure for most calls is { len: num_chars_consumed, token: str }
window.ABCJS.parse.tokenizer = function() {
	this.skipWhiteSpace = function(str) {
		for (var i = 0; i &lt; str.length; i++) {
		  if (!this.isWhiteSpace(str.charAt(i)))
				return i;
		}
		return str.length;	// It must have been all white space
	};
	var finished = function(str, i) {
		return i &gt;= str.length;
	};
	this.eatWhiteSpace = function(line, index) {
		for (var i = index; i &lt; line.length; i++) {
		  if (!this.isWhiteSpace(line.charAt(i)))
				return i-index;
		}
		return i-index;
	};

	// This just gets the basic pitch letter, ignoring leading spaces, and normalizing it to a capital
	this.getKeyPitch = function(str) {
		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return {len: 0};
		switch (str.charAt(i)) {
			case 'A':return {len: i+1, token: 'A'};
			case 'B':return {len: i+1, token: 'B'};
			case 'C':return {len: i+1, token: 'C'};
			case 'D':return {len: i+1, token: 'D'};
			case 'E':return {len: i+1, token: 'E'};
			case 'F':return {len: i+1, token: 'F'};
			case 'G':return {len: i+1, token: 'G'};
//			case 'a':return {len: i+1, token: 'A'};
//			case 'b':return {len: i+1, token: 'B'};
//			case 'c':return {len: i+1, token: 'C'};
//			case 'd':return {len: i+1, token: 'D'};
//			case 'e':return {len: i+1, token: 'E'};
//			case 'f':return {len: i+1, token: 'F'};
//			case 'g':return {len: i+1, token: 'G'};
		}
		return {len: 0};
	};

	// This just gets the basic accidental, ignoring leading spaces, and only the ones that appear in a key
	this.getSharpFlat = function(str) {
		if (str === 'bass')
			return {len: 0};
		switch (str.charAt(0)) {
			case '#':return {len: 1, token: '#'};
			case 'b':return {len: 1, token: 'b'};
		}
		return {len: 0};
	};

	this.getMode = function(str) {
		var skipAlpha = function(str, start) {
			// This returns the index of the next non-alphabetic char, or the entire length of the string if not found.
		  while (start &lt; str.length &amp;&amp; ((str.charAt(start) &gt;= 'a' &amp;&amp; str.charAt(start) &lt;= 'z') || (str.charAt(start) &gt;= 'A' &amp;&amp; str.charAt(start) &lt;= 'Z')))
				start++;
			return start;
		};

		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return {len: 0};
		var firstThree = str.substring(i,i+3).toLowerCase();
		if (firstThree.length &gt; 1 &amp;&amp; firstThree.charAt(1) === ' ' || firstThree.charAt(1) === '^' || firstThree.charAt(1) === '_' || firstThree.charAt(1) === '=') firstThree = firstThree.charAt(0);	// This will handle the case of 'm'
		switch (firstThree) {
			case 'mix':return {len: skipAlpha(str, i), token: 'Mix'};
			case 'dor':return {len: skipAlpha(str, i), token: 'Dor'};
			case 'phr':return {len: skipAlpha(str, i), token: 'Phr'};
			case 'lyd':return {len: skipAlpha(str, i), token: 'Lyd'};
			case 'loc':return {len: skipAlpha(str, i), token: 'Loc'};
			case 'aeo':return {len: skipAlpha(str, i), token: 'm'};
			case 'maj':return {len: skipAlpha(str, i), token: ''};
			case 'ion':return {len: skipAlpha(str, i), token: ''};
			case 'min':return {len: skipAlpha(str, i), token: 'm'};
			case 'm':return {len: skipAlpha(str, i), token: 'm'};
		}
		return {len: 0};
	};

	this.getClef = function(str, bExplicitOnly) {
		var strOrig = str;
		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return {len: 0};
		// The word 'clef' is optional, but if it appears, a clef MUST appear
		var needsClef = false;
		var strClef = str.substring(i);
		if (window.ABCJS.parse.startsWith(strClef, 'clef=')) {
			needsClef = true;
			strClef = strClef.substring(5);
			i += 5;
		}
		if (strClef.length === 0 &amp;&amp; needsClef)
			return {len: i+5, warn: &quot;No clef specified: &quot; + strOrig};

		var j = this.skipWhiteSpace(strClef);
		if (finished(strClef, j))
			return {len: 0};
		if (j &gt; 0) {
			i += j;
			strClef = strClef.substring(j);
		}
		var name = null;
		if (window.ABCJS.parse.startsWith(strClef, 'treble'))
			name = 'treble';
		else if (window.ABCJS.parse.startsWith(strClef, 'bass3'))
			name = 'bass3';
		else if (window.ABCJS.parse.startsWith(strClef, 'bass'))
			name = 'bass';
		else if (window.ABCJS.parse.startsWith(strClef, 'tenor'))
			name = 'tenor';
		else if (window.ABCJS.parse.startsWith(strClef, 'alto2'))
			name = 'alto2';
		else if (window.ABCJS.parse.startsWith(strClef, 'alto1'))
			name = 'alto1';
		else if (window.ABCJS.parse.startsWith(strClef, 'alto'))
			name = 'alto';
		else if (!bExplicitOnly &amp;&amp; (needsClef &amp;&amp; window.ABCJS.parse.startsWith(strClef, 'none')))
			name = 'none';
		else if (window.ABCJS.parse.startsWith(strClef, 'perc'))
			name = 'perc';
		else if (!bExplicitOnly &amp;&amp; (needsClef &amp;&amp; window.ABCJS.parse.startsWith(strClef, 'C')))
			name = 'tenor';
		else if (!bExplicitOnly &amp;&amp; (needsClef &amp;&amp; window.ABCJS.parse.startsWith(strClef, 'F')))
			name = 'bass';
		else if (!bExplicitOnly &amp;&amp; (needsClef &amp;&amp; window.ABCJS.parse.startsWith(strClef, 'G')))
			name = 'treble';
		else
			return {len: i+5, warn: &quot;Unknown clef specified: &quot; + strOrig};

		strClef = strClef.substring(name.length);
		j = this.isMatch(strClef, '+8');
		if (j &gt; 0)
			name += &quot;+8&quot;;
		else {
			j = this.isMatch(strClef, '-8');
			if (j &gt; 0)
				name += &quot;-8&quot;;
		}
		return {len: i+name.length, token: name, explicit: needsClef};
	};

	// This returns one of the legal bar lines
	// This is called alot and there is no obvious tokenable items, so this is broken apart.
	this.getBarLine = function(line, i) {
		switch (line.charAt(i)) {
			case ']':
				++i;
				switch (line.charAt(i)) {
					case '|': return {len: 2, token: &quot;bar_thick_thin&quot;};
					case '[':
						++i;
						if ((line.charAt(i) &gt;= '1' &amp;&amp; line.charAt(i) &lt;= '9') || line.charAt(i) === '&quot;')
							return {len: 2, token: &quot;bar_invisible&quot;};
						return {len: 1, warn: &quot;Unknown bar symbol&quot;};
					default:
						return {len: 1, token: &quot;bar_invisible&quot;};
				}
				break;
			case ':':
				++i;
				switch (line.charAt(i)) {
					case ':': return {len: 2, token: &quot;bar_dbl_repeat&quot;};
					case '|':	// :|
						++i;
						switch (line.charAt(i)) {
							case ']':	// :|]
								++i;
								switch (line.charAt(i)) {
									case '|':	// :|]|
										++i;
										if (line.charAt(i) === ':')  return {len: 5, token: &quot;bar_dbl_repeat&quot;};
										return {len: 3, token: &quot;bar_right_repeat&quot;};
									default:
										return {len: 3, token: &quot;bar_right_repeat&quot;};
								}
								break;
							case '|':	// :||
								++i;
								if (line.charAt(i) === ':')  return {len: 4, token: &quot;bar_dbl_repeat&quot;};
								return {len: 3, token: &quot;bar_right_repeat&quot;};
							default:
								return {len: 2, token: &quot;bar_right_repeat&quot;};
						}
						break;
					default:
						return {len: 1, warn: &quot;Unknown bar symbol&quot;};
				}
				break;
			case '[':	// [
				++i;
				if (line.charAt(i) === '|') {	// [|
					++i;
					switch (line.charAt(i)) {
						case ':': return {len: 3, token: &quot;bar_left_repeat&quot;};
						case ']': return {len: 3, token: &quot;bar_invisible&quot;};
						default: return {len: 2, token: &quot;bar_thick_thin&quot;};
					}
				} else {
					if ((line.charAt(i) &gt;= '1' &amp;&amp; line.charAt(i) &lt;= '9') || line.charAt(i) === '&quot;')
						return {len: 1, token: &quot;bar_invisible&quot;};
					return {len: 0};
				}
				break;
			case '|':	// |
				++i;
				switch (line.charAt(i)) {
					case ']': return {len: 2, token: &quot;bar_thin_thick&quot;};
					case '|': // ||
						++i;
						if (line.charAt(i) === ':') return {len: 3, token: &quot;bar_left_repeat&quot;};
						return {len: 2, token: &quot;bar_thin_thin&quot;};
					case ':':	// |:
						var colons = 0;
						while (line.charAt(i+colons) === ':') colons++;
						return { len: 1+colons, token: &quot;bar_left_repeat&quot;};
					default: return {len: 1, token: &quot;bar_thin&quot;};
				}
				break;
		}
		return {len: 0};
	};

	// this returns all the characters in the string that match one of the characters in the legalChars string
	this.getTokenOf = function(str, legalChars) {
		for (var i = 0; i &lt; str.length; i++) {
			if (legalChars.indexOf(str.charAt(i)) &lt; 0)
				return {len: i, token: str.substring(0, i)};
		}
		return {len: i, token: str};
	};

	this.getToken = function(str, start, end) {
		// This returns the next set of chars that doesn't contain spaces
		var i = start;
		while (i &lt; end &amp;&amp; !this.isWhiteSpace(str.charAt(i)))
			i++;
		return str.substring(start, i);
	};

	// This just sees if the next token is the word passed in, with possible leading spaces
	this.isMatch = function(str, match) {
		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return 0;
		if (window.ABCJS.parse.startsWith(str.substring(i), match))
			return i+match.length;
		return 0;
	};

	this.getPitchFromTokens = function(tokens) {
		var ret = { };
		var pitches = {A: 5, B: 6, C: 0, D: 1, E: 2, F: 3, G: 4, a: 12, b: 13, c: 7, d: 8, e: 9, f: 10, g: 11};
		ret.position = pitches[tokens[0].token];
		if (ret.position === undefined)
			return { warn: &quot;Pitch expected. Found: &quot; + tokens[0].token };
		tokens.shift();
		while (tokens.length) {
			switch (tokens[0].token) {
				case ',': ret.position -= 7; tokens.shift(); break;
				case '\'': ret.position += 7; tokens.shift(); break;
				default: return ret;
			}
		}
		return ret;
	};

	this.getKeyAccidentals2 = function(tokens) {
		var accs;
		// find and strip off all accidentals in the token list
		while (tokens.length &gt; 0) {
			var acc;
			if (tokens[0].token === '^') {
				acc = 'sharp';
				tokens.shift();
				if (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};
				switch (tokens[0].token) {
					case '^': acc = 'dblsharp'; tokens.shift(); break;
					case '/': acc = 'quartersharp'; tokens.shift(); break;
				}
			} else if (tokens[0].token === '=') {
				acc = 'natural';
				tokens.shift();
			} else if (tokens[0].token === '_') {
				acc = 'flat';
				tokens.shift();
				if (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};
				switch (tokens[0].token) {
					case '_': acc = 'dblflat'; tokens.shift(); break;
					case '/': acc = 'quarterflat'; tokens.shift(); break;
				}
			} else {
				// Not an accidental, we'll assume that a later parse will recognize it.
				return { accs: accs };
			}
			if (tokens.length === 0) return {accs: accs, warn: 'Expected note name after ' + acc};
			switch (tokens[0].token.charAt(0))
			{
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
					if (accs === undefined)
						accs = [];
					accs.push({ acc: acc, note: tokens[0].token.charAt(0) });
					if (tokens[0].token.length === 1)
						tokens.shift();
					else
						tokens[0].token = tokens[0].token.substring(1);
					break;
				default:
					return {accs: accs, warn: 'Expected note name after ' + acc + ' Found: ' + tokens[0].token };
			}
		}
		return { accs: accs };
	};

	// This gets an accidental marking for the key signature. It has the accidental then the pitch letter.
	this.getKeyAccidental = function(str) {
		var accTranslation = {
			'^': 'sharp',
			'^^': 'dblsharp',
			'=': 'natural',
			'_': 'flat',
			'__': 'dblflat',
			'_/': 'quarterflat',
			'^/': 'quartersharp'
		};
		var i = this.skipWhiteSpace(str);
		if (finished(str, i))
			return {len: 0};
		var acc = null;
		switch (str.charAt(i))
		{
			case '^':
			case '_':
			case '=':
				acc = str.charAt(i);
				break;
			default:return {len: 0};
		}
		i++;
		if (finished(str, i))
			return {len: 1, warn: 'Expected note name after accidental'};
		switch (str.charAt(i))
		{
			case 'a':
			case 'b':
			case 'c':
			case 'd':
			case 'e':
			case 'f':
			case 'g':
			case 'A':
			case 'B':
			case 'C':
			case 'D':
			case 'E':
			case 'F':
			case 'G':
				return {len: i+1, token: {acc: accTranslation[acc], note: str.charAt(i)}};
			case '^':
			case '_':
			case '/':
				acc += str.charAt(i);
				i++;
				if (finished(str, i))
					return {len: 2, warn: 'Expected note name after accidental'};
				switch (str.charAt(i))
				{
					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
					case 'g':
					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
					case 'G':
						return {len: i+1, token: {acc: accTranslation[acc], note: str.charAt(i)}};
					default:
						return {len: 2, warn: 'Expected note name after accidental'};
				}
				break;
			default:
				return {len: 1, warn: 'Expected note name after accidental'};
		}
	};

	this.isWhiteSpace = function(ch) {
		return ch === ' ' || ch === '\t' || ch === '\x12';
	};

	this.getMeat = function(line, start, end) {
		// This removes any comments starting with '%' and trims the ends of the string so that there are no leading or trailing spaces.
		// it returns just the start and end characters that contain the meat.
		var comment = line.indexOf('%', start);
		if (comment &gt;= 0 &amp;&amp; comment &lt; end)
			end = comment;
		while (start &lt; end &amp;&amp; (line.charAt(start) === ' ' || line.charAt(start) === '\t' || line.charAt(start) === '\x12'))
			start++;
		while (start &lt; end &amp;&amp; (line.charAt(end-1) === ' ' || line.charAt(end-1) === '\t' || line.charAt(end-1) === '\x12'))
			end--;
		return {start: start, end: end};
	};

	var isLetter = function(ch) {
		return (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z');
	};

	var isNumber = function(ch) {
		return (ch &gt;= '0' &amp;&amp; ch &lt;= '9');
	};

	this.tokenize = function(line, start, end) {
		// this returns all the tokens inside the passed string. A token is a punctuation mark, a string of digits, a string of letters.
		//  Quoted strings are one token.
		//  If there is a minus sign next to a number, then it is included in the number.
		// If there is a period immediately after a number, with a number immediately following, then a float is returned.
		// The type of token is returned: quote, alpha, number, punct
		var ret = this.getMeat(line, start, end);
		start = ret.start;
		end = ret.end;
		var tokens = [];
		var i;
		while (start &lt; end) {
			if (line.charAt(start) === '&quot;') {
				i = start+1;
				while (i &lt; end &amp;&amp; line.charAt(i) !== '&quot;') i++;
				tokens.push({ type: 'quote', token: line.substring(start+1, i), start: start+1, end: i});
				i++;
			} else if (isLetter(line.charAt(start))) {
				i = start+1;
				while (i &lt; end &amp;&amp; isLetter(line.charAt(i))) i++;
				tokens.push({ type: 'alpha', token: line.substring(start, i), continueId: isNumber(line.charAt(i)), start: start, end: i});
				start = i + 1;
			} else if (line.charAt(start) === '.' &amp;&amp; isNumber(line.charAt(i+1))) {
				i = start+1;
				var int2 = null;
				var float2 = null;
				while (i &lt; end &amp;&amp; isNumber(line.charAt(i))) i++;

				float2 = parseFloat(line.substring(start, i));
				tokens.push({ type: 'number', token: line.substring(start, i), intt: int2, floatt: float2, continueId: isLetter(line.charAt(i)), start: start, end: i});
				start = i + 1;
			} else if (isNumber(line.charAt(start)) || (line.charAt(start) === '-' &amp;&amp; isNumber(line.charAt(i+1)))) {
				i = start+1;
				var intt = null;
				var floatt = null;
				while (i &lt; end &amp;&amp; isNumber(line.charAt(i))) i++;
				if (line.charAt(i) === '.' &amp;&amp; isNumber(line.charAt(i+1))) {
					i++;
					while (i &lt; end &amp;&amp; isNumber(line.charAt(i))) i++;
				} else
					intt = parseInt(line.substring(start, i));

				floatt = parseFloat(line.substring(start, i));
				tokens.push({ type: 'number', token: line.substring(start, i), intt: intt, floatt: floatt, continueId: isLetter(line.charAt(i)), start: start, end: i});
				start = i + 1;
			} else if (line.charAt(start) === ' ' || line.charAt(start) === '\t') {
				i = start+1;
			} else {
				tokens.push({ type: 'punct', token: line.charAt(start), start: start, end: start+1});
				i = start+1;
			}
			start = i;
		}
		return tokens;
	};

	this.getVoiceToken = function(line, start, end) {
		// This finds the next token. A token is delimited by a space or an equal sign. If it starts with a quote, then the portion between the quotes is returned.
		var i = start;
		while (i &lt; end &amp;&amp; this.isWhiteSpace(line.charAt(i)) || line.charAt(i) === '=')
			i++;

		if (line.charAt(i) === '&quot;') {
			var close = line.indexOf('&quot;', i+1);
			if (close === -1 || close &gt;= end)
				return {len: 1, err: &quot;Missing close quote&quot;};
			return {len: close-start+1, token: this.translateString(line.substring(i+1, close))};
		} else {
			var ii = i;
			while (ii &lt; end &amp;&amp; !this.isWhiteSpace(line.charAt(ii)) &amp;&amp; line.charAt(ii) !== '=')
				ii++;
			return {len: ii-start+1, token: line.substring(i, ii)};
		}
	};

	var charMap = {
		&quot;`a&quot;: 'à', &quot;'a&quot;: &quot;á&quot;, &quot;^a&quot;: &quot;â&quot;, &quot;~a&quot;: &quot;ã&quot;, &quot;\&quot;a&quot;: &quot;ä&quot;, &quot;oa&quot;: &quot;å&quot;, &quot;=a&quot;: &quot;ā&quot;, &quot;ua&quot;: &quot;ă&quot;, &quot;;a&quot;: &quot;ą&quot;,
		&quot;`e&quot;: 'è', &quot;'e&quot;: &quot;é&quot;, &quot;^e&quot;: &quot;ê&quot;, &quot;\&quot;e&quot;: &quot;ë&quot;, &quot;=e&quot;: &quot;ē&quot;, &quot;ue&quot;: &quot;ĕ&quot;, &quot;;e&quot;: &quot;ę&quot;, &quot;.e&quot;: &quot;ė&quot;,
		&quot;`i&quot;: 'ì', &quot;'i&quot;: &quot;í&quot;, &quot;^i&quot;: &quot;î&quot;, &quot;\&quot;i&quot;: &quot;ï&quot;, &quot;=i&quot;: &quot;ī&quot;, &quot;ui&quot;: &quot;ĭ&quot;, &quot;;i&quot;: &quot;į&quot;,
		&quot;`o&quot;: 'ò', &quot;'o&quot;: &quot;ó&quot;, &quot;^o&quot;: &quot;ô&quot;, &quot;~o&quot;: &quot;õ&quot;, &quot;\&quot;o&quot;: &quot;ö&quot;, &quot;=o&quot;: &quot;ō&quot;, &quot;uo&quot;: &quot;ŏ&quot;, &quot;/o&quot;: &quot;ø&quot;,
		&quot;`u&quot;: 'ù', &quot;'u&quot;: &quot;ú&quot;, &quot;^u&quot;: &quot;û&quot;, &quot;~u&quot;: &quot;ũ&quot;, &quot;\&quot;u&quot;: &quot;ü&quot;, &quot;ou&quot;: &quot;ů&quot;, &quot;=u&quot;: &quot;ū&quot;, &quot;uu&quot;: &quot;ŭ&quot;, &quot;;u&quot;: &quot;ų&quot;,
		&quot;`A&quot;: 'À', &quot;'A&quot;: &quot;Á&quot;, &quot;^A&quot;: &quot;Â&quot;, &quot;~A&quot;: &quot;Ã&quot;, &quot;\&quot;A&quot;: &quot;Ä&quot;, &quot;oA&quot;: &quot;Å&quot;, &quot;=A&quot;: &quot;Ā&quot;, &quot;uA&quot;: &quot;Ă&quot;, &quot;;A&quot;: &quot;Ą&quot;,
		&quot;`E&quot;: 'È', &quot;'E&quot;: &quot;É&quot;, &quot;^E&quot;: &quot;Ê&quot;, &quot;\&quot;E&quot;: &quot;Ë&quot;, &quot;=E&quot;: &quot;Ē&quot;, &quot;uE&quot;: &quot;Ĕ&quot;, &quot;;E&quot;: &quot;Ę&quot;, &quot;.E&quot;: &quot;Ė&quot;,
		&quot;`I&quot;: 'Ì', &quot;'I&quot;: &quot;Í&quot;, &quot;^I&quot;: &quot;Î&quot;, &quot;~I&quot;: &quot;Ĩ&quot;, &quot;\&quot;I&quot;: &quot;Ï&quot;, &quot;=I&quot;: &quot;Ī&quot;, &quot;uI&quot;: &quot;Ĭ&quot;, &quot;;I&quot;: &quot;Į&quot;, &quot;.I&quot;: &quot;İ&quot;,
		&quot;`O&quot;: 'Ò', &quot;'O&quot;: &quot;Ó&quot;, &quot;^O&quot;: &quot;Ô&quot;, &quot;~O&quot;: &quot;Õ&quot;, &quot;\&quot;O&quot;: &quot;Ö&quot;, &quot;=O&quot;: &quot;Ō&quot;, &quot;uO&quot;: &quot;Ŏ&quot;, &quot;/O&quot;: &quot;Ø&quot;,
		&quot;`U&quot;: 'Ù', &quot;'U&quot;: &quot;Ú&quot;, &quot;^U&quot;: &quot;Û&quot;, &quot;~U&quot;: &quot;Ũ&quot;, &quot;\&quot;U&quot;: &quot;Ü&quot;, &quot;oU&quot;: &quot;Ů&quot;, &quot;=U&quot;: &quot;Ū&quot;, &quot;uU&quot;: &quot;Ŭ&quot;, &quot;;U&quot;: &quot;Ų&quot;,
		&quot;ae&quot;: &quot;æ&quot;, &quot;AE&quot;: &quot;Æ&quot;, &quot;oe&quot;: &quot;œ&quot;, &quot;OE&quot;: &quot;Œ&quot;, &quot;ss&quot;: &quot;ß&quot;,
		&quot;'c&quot;: &quot;ć&quot;, &quot;^c&quot;: &quot;ĉ&quot;, &quot;uc&quot;: &quot;č&quot;, &quot;cc&quot;: &quot;ç&quot;, &quot;.c&quot;: &quot;ċ&quot;, &quot;cC&quot;: &quot;Ç&quot;, &quot;'C&quot;: &quot;Ć&quot;, &quot;^C&quot;: &quot;Ĉ&quot;, &quot;uC&quot;: &quot;Č&quot;, &quot;.C&quot;: &quot;Ċ&quot;,
		&quot;~n&quot;: &quot;ñ&quot;,
		&quot;=s&quot;: &quot;š&quot;, &quot;vs&quot;: &quot;š&quot;,
		&quot;vz&quot;: 'ž'

// More chars: Ñ Ĳ ĳ Ď ď Đ đ Ĝ ĝ Ğ ğ Ġ ġ Ģ ģ Ĥ ĥ Ħ ħ Ĵ ĵ Ķ ķ ĸ Ĺ ĺ Ļ ļ Ľ ľ Ŀ ŀ Ł ł Ń ń Ņ ņ Ň ň ŉ Ŋ ŋ   Ŕ ŕ Ŗ ŗ Ř ř Ś ś Ŝ ŝ Ş ş Š Ţ ţ Ť ť Ŧ ŧ Ŵ ŵ Ŷ ŷ Ÿ ÿ Ÿ Ź ź Ż ż Ž 
	};
	var charMap1 = {
		&quot;#&quot;: &quot;♯&quot;,
		&quot;b&quot;: &quot;♭&quot;,
		&quot;=&quot;: &quot;♮&quot;
	};
	var charMap2 = {
		&quot;201&quot;: &quot;♯&quot;,
		&quot;202&quot;: &quot;♭&quot;,
		&quot;203&quot;: &quot;♮&quot;,
		&quot;241&quot;: &quot;¡&quot;,
		&quot;242&quot;: &quot;¢&quot;, &quot;252&quot;: &quot;a&quot;, &quot;262&quot;: &quot;2&quot;, &quot;272&quot;: &quot;o&quot;, &quot;302&quot;: &quot;Â&quot;, &quot;312&quot;: &quot;Ê&quot;, &quot;322&quot;: &quot;Ò&quot;, &quot;332&quot;: &quot;Ú&quot;, &quot;342&quot;: &quot;â&quot;, &quot;352&quot;: &quot;ê&quot;, &quot;362&quot;: &quot;ò&quot;, &quot;372&quot;: &quot;ú&quot;,
		&quot;243&quot;: &quot;£&quot;, &quot;253&quot;: &quot;«&quot;, &quot;263&quot;: &quot;3&quot;, &quot;273&quot;: &quot;»&quot;, &quot;303&quot;: &quot;Ã&quot;, &quot;313&quot;: &quot;Ë&quot;, &quot;323&quot;: &quot;Ó&quot;, &quot;333&quot;: &quot;Û&quot;, &quot;343&quot;: &quot;ã&quot;, &quot;353&quot;: &quot;ë&quot;, &quot;363&quot;: &quot;ó&quot;, &quot;373&quot;: &quot;û&quot;,
		&quot;244&quot;: &quot;¤&quot;, &quot;254&quot;: &quot;¬&quot;, &quot;264&quot;: &quot;  ́&quot;, &quot;274&quot;: &quot;1⁄4&quot;, &quot;304&quot;: &quot;Ä&quot;, &quot;314&quot;: &quot;Ì&quot;, &quot;324&quot;: &quot;Ô&quot;, &quot;334&quot;: &quot;Ü&quot;, &quot;344&quot;: &quot;ä&quot;, &quot;354&quot;: &quot;ì&quot;, &quot;364&quot;: &quot;ô&quot;, &quot;374&quot;: &quot;ü&quot;,
		&quot;245&quot;: &quot;¥&quot;, &quot;255&quot;: &quot;-&quot;, &quot;265&quot;: &quot;μ&quot;, &quot;275&quot;: &quot;1⁄2&quot;, &quot;305&quot;: &quot;Å&quot;, &quot;315&quot;: &quot;Í&quot;, &quot;325&quot;: &quot;Õ&quot;, &quot;335&quot;: &quot;Ý&quot;,  &quot;345&quot;: &quot;å&quot;, &quot;355&quot;: &quot;í&quot;, &quot;365&quot;: &quot;õ&quot;, &quot;375&quot;: &quot;ý&quot;,
		&quot;246&quot;: &quot;¦&quot;, &quot;256&quot;: &quot;®&quot;, &quot;266&quot;: &quot;¶&quot;, &quot;276&quot;: &quot;3⁄4&quot;, &quot;306&quot;: &quot;Æ&quot;, &quot;316&quot;: &quot;Î&quot;, &quot;326&quot;: &quot;Ö&quot;, &quot;336&quot;: &quot;Þ&quot;, &quot;346&quot;: &quot;æ&quot;, &quot;356&quot;: &quot;î&quot;, &quot;366&quot;: &quot;ö&quot;, &quot;376&quot;: &quot;þ&quot;,
		&quot;247&quot;: &quot;§&quot;, &quot;257&quot;: &quot; ̄&quot;, &quot;267&quot;: &quot;·&quot;, &quot;277&quot;: &quot;¿&quot;, &quot;307&quot;: &quot;Ç&quot;, &quot;317&quot;: &quot;Ï&quot;, &quot;327&quot;: &quot;×&quot;, &quot;337&quot;: &quot;ß&quot;, &quot;347&quot;: &quot;ç&quot;, &quot;357&quot;: &quot;ï&quot;, &quot;367&quot;: &quot;÷&quot;, &quot;377&quot;: &quot;ÿ&quot;,
		&quot;250&quot;: &quot; ̈&quot;, &quot;260&quot;: &quot;°&quot;, &quot;270&quot;: &quot; ̧&quot;, &quot;300&quot;: &quot;À&quot;, &quot;310&quot;: &quot;È&quot;, &quot;320&quot;: &quot;Ð&quot;, &quot;330&quot;: &quot;Ø&quot;, &quot;340&quot;: &quot;à&quot;, &quot;350&quot;: &quot;è&quot;, &quot;360&quot;: &quot;ð&quot;, &quot;370&quot;: &quot;ø&quot;,
		&quot;251&quot;: &quot;©&quot;, &quot;261&quot;: &quot;±&quot;, &quot;271&quot;: &quot;1&quot;, &quot;301&quot;: &quot;Á&quot;, &quot;311&quot;: &quot;É&quot;, &quot;321&quot;: &quot;Ñ&quot;, &quot;331&quot;: &quot;Ù&quot;, &quot;341&quot;: &quot;á&quot;, &quot;351&quot;: &quot;é&quot;, &quot;361&quot;: &quot;ñ&quot;, &quot;371&quot;: &quot;ù&quot; };
	this.translateString = function(str) {
		var arr = str.split('\\');
		if (arr.length === 1) return str;
		var out = null;
		window.ABCJS.parse.each(arr, function(s) {
			if (out === null)
				out = s;
			else {
				var c = charMap[s.substring(0, 2)];
				if (c !== undefined)
					out += c + s.substring(2);
				else {
					c = charMap2[s.substring(0, 3)];
					if (c !== undefined)
						out += c + s.substring(3);
					else {
						c = charMap1[s.substring(0, 1)];
						if (c !== undefined)
							out += c + s.substring(1);
						else
							out += &quot;\\&quot; + s;
					}
				}
			}
		});
		return out;
	};
	this.getNumber = function(line, index) {
		var num = 0;
		while (index &lt; line.length) {
			switch (line.charAt(index)) {
				case '0':num = num*10;index++;break;
				case '1':num = num*10+1;index++;break;
				case '2':num = num*10+2;index++;break;
				case '3':num = num*10+3;index++;break;
				case '4':num = num*10+4;index++;break;
				case '5':num = num*10+5;index++;break;
				case '6':num = num*10+6;index++;break;
				case '7':num = num*10+7;index++;break;
				case '8':num = num*10+8;index++;break;
				case '9':num = num*10+9;index++;break;
				default:
					return {num: num, index: index};
			}
		}
		return {num: num, index: index};
	};

	this.getFraction = function(line, index) {
		var num = 1;
		var den = 1;
		if (line.charAt(index) !== '/') {
			var ret = this.getNumber(line, index);
			num = ret.num;
			index = ret.index;
		}
		if (line.charAt(index) === '/') {
			index++;
			if (line.charAt(index) === '/') {
				var div = 0.5;
				while (line.charAt(index++) === '/')
					div = div /2;
				return {value: num * div, index: index-1};
			} else {
				var iSave = index;
				var ret2 = this.getNumber(line, index);
				if (ret2.num === 0 &amp;&amp; iSave === index)	// If we didn't use any characters, it is an implied 2
					ret2.num = 2;
				if (ret2.num !== 0)
					den = ret2.num;
				index = ret2.index;
			}
		}

		return {value: num/den, index: index};
	};

	this.theReverser = function(str) {
		if (window.ABCJS.parse.endsWith(str, &quot;, The&quot;))
			return &quot;The &quot; + str.substring(0, str.length-5);
		if (window.ABCJS.parse.endsWith(str, &quot;, A&quot;))
			return &quot;A &quot; + str.substring(0, str.length-3);
		return str;
	};

	this.stripComment = function(str) {
		var i = str.indexOf('%');
		if (i &gt;= 0)
			return window.ABCJS.parse.strip(str.substring(0, i));
		return window.ABCJS.parse.strip(str);
	};

	this.getInt = function(str) {
		// This parses the beginning of the string for a number and returns { value: num, digits: num }
		// If digits is 0, then the string didn't point to a number.
		var x = parseInt(str);
		if (isNaN(x))
			return {digits: 0};
		var s = &quot;&quot; + x;
		var i = str.indexOf(s);	// This is to account for leading spaces
		return {value: x, digits: i+s.length};
	};

	this.getFloat = function(str) {
		// This parses the beginning of the string for a number and returns { value: num, digits: num }
		// If digits is 0, then the string didn't point to a number.
		var x = parseFloat(str);
		if (isNaN(x))
			return {digits: 0};
		var s = &quot;&quot; + x;
		var i = str.indexOf(s);	// This is to account for leading spaces
		return {value: x, digits: i+s.length};
	};

	this.getMeasurement = function(tokens) {
		if (tokens.length === 0) return { used: 0 };
		var used = 1;
		var num = '';
		if (tokens[0].token === '-') {
			tokens.shift();
			num = '-';
			used++;
		}
		else if (tokens[0].type !== 'number') return { used: 0 };
		num += tokens.shift().token;
		if (tokens.length === 0) return { used: 1, value: parseInt(num) };
		var x = tokens.shift();
		if (x.token === '.') {
			used++;
			if (tokens.length === 0) return { used: used, value: parseInt(num) };
			if (tokens[0].type === 'number') {
				x = tokens.shift();
				num = num + '.' + x.token;
				used++;
				if (tokens.length === 0) return { used: used, value: parseFloat(num) };
			}
			x = tokens.shift();
		}
		switch (x.token) {
			case 'pt': return { used: used+1, value: parseFloat(num) };
			case 'cm': return { used: used+1, value: parseFloat(num)/2.54*72 };
			case 'in': return { used: used+1, value: parseFloat(num)*72 };
			default: tokens.unshift(x); return { used: used, value: parseFloat(num) };
		}
		return { used: 0 };
	};
	var substInChord = function(str)
	{
		while ( str.indexOf(&quot;\\n&quot;) !== -1)
		{
			str = str.replace(&quot;\\n&quot;, &quot;\n&quot;);
		}
		return str;
	};
	this.getBrackettedSubstring = function(line, i, maxErrorChars, _matchChar)
	{
		// This extracts the sub string by looking at the first character and searching for that
		// character later in the line (or search for the optional _matchChar).
		// For instance, if the first character is a quote it will look for
		// the end quote. If the end of the line is reached, then only up to the default number
		// of characters are returned, so that a missing end quote won't eat up the entire line.
		// It returns the substring and the number of characters consumed.
		// The number of characters consumed is normally two more than the size of the substring,
		// but in the error case it might not be.
		var matchChar = _matchChar || line.charAt(i);
		var pos = i+1;
		while ((pos &lt; line.length) &amp;&amp; (line.charAt(pos) !== matchChar))
			++pos;
		if (line.charAt(pos) === matchChar)
			return [pos-i+1,substInChord(line.substring(i+1, pos)), true];
		else	// we hit the end of line, so we'll just pick an arbitrary num of chars so the line doesn't disappear.
		{
			pos = i+maxErrorChars;
			if (pos &gt; line.length-1)
				pos = line.length-1;
			return [pos-i+1, substInChord(line.substring(i+1, pos)), false];
		}
	};
};
</pre>
</body>
</html>
